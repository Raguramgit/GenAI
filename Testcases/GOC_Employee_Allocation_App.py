"""
Employee Allocation System - Streamlit Single-file App
Author: Generated by ChatGPT

Features implemented:
- Employee Master Record: Add/Edit/Delete employees and allocations (billable/unbillable) across projects
- Dashboard & Reporting: Visual summaries (totals, distributions, band-wise, tech tower, billed vs unbilled, project-wise billed)
- Account Onboarding: Add customers with multiple project codes and finance ID
- Notifications: Email notifications (SMTP settings; send on allocation change)
- Import/Export: Bulk import/export via Excel
- Admin Module: Basic role-based access control (RBAC) stored in DB
- Monthly Lifecycle Tracking: Filter lists for joiners, releases, resignations with export
- Audit Trail: Immutable history of CRUD and allocation changes

Notes:
- Uses SQLite for persistence (local file: employee_alloc.db)
- Intended as a starting, configurable app; update SMTP and security for production

Run: streamlit run employee_allocation_app.py
"""

import streamlit as st
import pandas as pd
import sqlite3
from datetime import datetime, date
import io
import smtplib
from email.message import EmailMessage
import plotly.express as px

DB_FILE = "employee_alloc.db"

# -------------------------
# Database helpers
# -------------------------

def get_conn():
    conn = sqlite3.connect(DB_FILE, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn


def init_db():
    conn = get_conn()
    c = conn.cursor()

    # Employees
    c.execute("""
    CREATE TABLE IF NOT EXISTS employees (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        emp_code TEXT UNIQUE,
        name TEXT,
        band TEXT,
        technology TEXT,
        gender TEXT,
        status TEXT DEFAULT 'Active',
        grad TEXT,
        reporting_manager TEXT,
        email TEXT,
        created_at TEXT,
        updated_at TEXT
    )
    """)

    # Accounts / Projects
    c.execute("""
    CREATE TABLE IF NOT EXISTS accounts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        customer_name TEXT,
        project_name TEXT,
        project_code TEXT,
        finance_id TEXT,
        delivery_stakeholder TEXT,
        created_at TEXT
    )
    """)

    # Allocations
    c.execute("""
    CREATE TABLE IF NOT EXISTS allocations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        emp_id INTEGER,
        account_id INTEGER,
        project_code TEXT,
        billed REAL DEFAULT 0.0,
        unbilled REAL DEFAULT 0.0,
        effective_from TEXT,
        effective_to TEXT,
        notes TEXT,
        created_at TEXT,
        updated_at TEXT,
        FOREIGN KEY(emp_id) REFERENCES employees(id),
        FOREIGN KEY(account_id) REFERENCES accounts(id)
    )
    """)

    # Users / RBAC
    c.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE,
        full_name TEXT,
        role TEXT,
        email TEXT
    )
    """)

    # Audit trail (immutable append-only)
    c.execute("""
    CREATE TABLE IF NOT EXISTS audit (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        entity_type TEXT,
        entity_id INTEGER,
        action TEXT,
        details TEXT,
        performed_by TEXT,
        performed_at TEXT
    )
    """)

    conn.commit()
    conn.close()


# -------------------------
# Audit helper
# -------------------------

def audit_log(entity_type, entity_id, action, details, performed_by="system"):
    conn = get_conn()
    c = conn.cursor()
    c.execute(
        "INSERT INTO audit (entity_type, entity_id, action, details, performed_by, performed_at) VALUES (?, ?, ?, ?, ?, ?)",
        (entity_type, entity_id or 0, action, details, performed_by, datetime.utcnow().isoformat()),
    )
    conn.commit()
    conn.close()


# -------------------------
# Email notifications (simple SMTP)
# -------------------------

def send_email_notification(subject, body, recipients, smtp_cfg):
    # smtp_cfg: dict {host, port, username, password, use_tls}
    if not recipients:
        return False, "No recipients"
    try:
        msg = EmailMessage()
        msg["Subject"] = subject
        msg["From"] = smtp_cfg.get("username")
        msg["To"] = ", ".join(recipients)
        msg.set_content(body)

        server = smtplib.SMTP(smtp_cfg.get("host"), smtp_cfg.get("port"))
        if smtp_cfg.get("use_tls", True):
            server.starttls()
        if smtp_cfg.get("username"):
            server.login(smtp_cfg.get("username"), smtp_cfg.get("password"))
        server.send_message(msg)
        server.quit()
        return True, "Sent"
    except Exception as e:
        return False, str(e)


# -------------------------
# CRUD: Employees
# -------------------------

def create_employee(emp_code, name, band, technology, gender, grad, reporting_manager, email, performed_by):
    conn = get_conn()
    c = conn.cursor()
    now = datetime.utcnow().isoformat()
    c.execute(
        "INSERT INTO employees (emp_code, name, band, technology, gender, grad, reporting_manager, email, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
        (emp_code, name, band, technology, gender, grad, reporting_manager, email, now, now),
    )
    emp_id = c.lastrowid
    conn.commit()
    conn.close()
    audit_log("employee", emp_id, "create", f"Created employee {name} ({emp_code})", performed_by)
    return emp_id


def update_employee(emp_id, **kwargs):
    conn = get_conn()
    c = conn.cursor()
    keys = []
    vals = []
    for k, v in kwargs.items():
        keys.append(f"{k} = ?")
        vals.append(v)
    vals.append(emp_id)
    q = f"UPDATE employees SET {', '.join(keys)}, updated_at = ? WHERE id = ?"
    vals.insert(-1, datetime.utcnow().isoformat())
    c.execute(q, vals)
    conn.commit()
    conn.close()
    audit_log("employee", emp_id, "update", f"Updated fields: {', '.join(kwargs.keys())}", kwargs.get('performed_by', 'system'))


def delete_employee(emp_id, performed_by):
    conn = get_conn()
    c = conn.cursor()
    c.execute("DELETE FROM employees WHERE id = ?", (emp_id,))
    conn.commit()
    conn.close()
    audit_log("employee", emp_id, "delete", "Deleted employee", performed_by)


def get_employees_df():
    conn = get_conn()
    df = pd.read_sql_query("SELECT * FROM employees", conn)
    conn.close()
    return df


# -------------------------
# Allocations CRUD
# -------------------------

def create_allocation(emp_id, account_id, project_code, billed, unbilled, effective_from, effective_to, notes, performed_by, notify=True, smtp_cfg=None):
    conn = get_conn()
    c = conn.cursor()
    now = datetime.utcnow().isoformat()
    c.execute(
        "INSERT INTO allocations (emp_id, account_id, project_code, billed, unbilled, effective_from, effective_to, notes, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
        (emp_id, account_id, project_code, billed, unbilled, effective_from, effective_to, notes, now, now),
    )
    alloc_id = c.lastrowid
    conn.commit()
    conn.close()
    audit_log("allocation", alloc_id, "create", f"Allocated emp {emp_id} to project {project_code} billed={billed} unbilled={unbilled}", performed_by)

    if notify and smtp_cfg:
        # fetch emails
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("SELECT email, reporting_manager FROM employees WHERE id = ?", (emp_id,))
        row = cur.fetchone()
        conn.close()
        recipients = []
        if row and row[0]:
            recipients.append(row[0])
        if row and row[1]:
            # try to find manager
            conn = get_conn()
            cur = conn.cursor()
            cur.execute("SELECT email FROM employees WHERE name = ?", (row[1],))
            m = cur.fetchone()
            conn.close()
            if m and m[0]:
                recipients.append(m[0])
        subject = f"Allocation updated for employee ID {emp_id}"
        body = f"An allocation was created: Project {project_code} billed={billed} unbilled={unbilled}\nNotes: {notes}"
        try:
            send_email_notification(subject, body, recipients, smtp_cfg)
        except Exception:
            pass

    return alloc_id


def get_allocations_df():
    conn = get_conn()
    df = pd.read_sql_query(
        "SELECT a.*, e.name as employee_name, acc.customer_name, acc.project_name FROM allocations a LEFT JOIN employees e ON a.emp_id=e.id LEFT JOIN accounts acc ON a.account_id=acc.id",
        conn,
    )
    conn.close()
    return df


# -------------------------
# Accounts onboard
# -------------------------

def create_account(customer_name, project_name, project_codes, finance_id, delivery_stakeholder, performed_by):
    conn = get_conn()
    c = conn.cursor()
    now = datetime.utcnow().isoformat()
    created_ids = []
    for code in project_codes:
        c.execute(
            "INSERT INTO accounts (customer_name, project_name, project_code, finance_id, delivery_stakeholder, created_at) VALUES (?, ?, ?, ?, ?, ?)",
            (customer_name, project_name, code, finance_id, delivery_stakeholder, now),
        )
        created_ids.append(c.lastrowid)
    conn.commit()
    conn.close()
    audit_log("account", None, "create", f"Onboarded account {customer_name} project {project_name} codes={project_codes}", performed_by)
    return created_ids


# -------------------------
# Import / Export helpers
# -------------------------

def import_employees_from_excel(file_bytes, performed_by):
    df = pd.read_excel(io.BytesIO(file_bytes))
    # expected columns: emp_code,name,band,technology,gender,grad,reporting_manager,email
    required = ["emp_code", "name"]
    errors = []
    count = 0
    for idx, row in df.iterrows():
        if pd.isna(row.get("emp_code")) or pd.isna(row.get("name")):
            errors.append((idx + 2, "Missing emp_code or name"))
            continue
        try:
            create_employee(
                emp_code=str(row.get("emp_code")),
                name=row.get("name"),
                band=row.get("band"),
                technology=row.get("technology"),
                gender=row.get("gender"),
                grad=row.get("grad"),
                reporting_manager=row.get("reporting_manager"),
                email=row.get("email"),
                performed_by=performed_by,
            )
            count += 1
        except Exception as e:
            errors.append((idx + 2, str(e)))
    return count, errors


# -------------------------
# Admin: RBAC simple
# -------------------------

def create_user(username, full_name, role, email):
    conn = get_conn()
    c = conn.cursor()
    c.execute("INSERT OR IGNORE INTO users (username, full_name, role, email) VALUES (?, ?, ?, ?)", (username, full_name, role, email))
    conn.commit()
    conn.close()
    audit_log("user", None, "create", f"Created user {username} role={role}", username)


def get_users_df():
    conn = get_conn()
    df = pd.read_sql_query("SELECT * FROM users", conn)
    conn.close()
    return df


# -------------------------
# Utility / Dashboard data
# -------------------------

def build_dashboard_metrics():
    emp_df = get_employees_df()
    alloc_df = get_allocations_df()
    acct_df = pd.read_sql_query("SELECT * FROM accounts", get_conn())

    total_employees = len(emp_df)
    active = int((emp_df['status'] == 'Active').sum()) if not emp_df.empty else 0
    resigned = int((emp_df['status'] != 'Active').sum()) if not emp_df.empty else 0

    band_counts = emp_df['band'].value_counts().to_dict() if not emp_df.empty else {}
    gender = emp_df['gender'].value_counts().to_dict() if not emp_df.empty else {}
    tech = emp_df['technology'].value_counts().to_dict() if not emp_df.empty else {}

    billed_total = float(alloc_df['billed'].sum()) if not alloc_df.empty else 0.0
    unbilled_total = float(alloc_df['unbilled'].sum()) if not alloc_df.empty else 0.0

    project_billed = alloc_df.groupby('project_code')['billed'].sum().sort_values(ascending=False).head(10).to_dict() if not alloc_df.empty else {}

    return {
        'total_employees': total_employees,
        'active': active,
        'resigned': resigned,
        'band_counts': band_counts,
        'gender': gender,
        'tech': tech,
        'billed_total': billed_total,
        'unbilled_total': unbilled_total,
        'project_billed': project_billed,
        'acct_count': len(acct_df),
    }


# -------------------------
# Streamlit UI
# -------------------------

init_db()

st.set_page_config(page_title="Employee Allocation System", layout="wide")

# Basic session user (for demo)
if 'current_user' not in st.session_state:
    st.session_state.current_user = st.text_input("Enter your username for this session (demo)", value="admin")

current_user = st.session_state.get('current_user', 'admin')

# Top-level navigation
st.title("Employee Allocation System")
menu = st.sidebar.selectbox("Go to", ["Dashboard", "Employee Master", "Account Onboarding", "Allocations", "Import/Export", "Lifecycle", "Admin Console", "Audit Trail", "Settings"]) 

# Load SMTP settings from session state or empty defaults
if 'smtp_cfg' not in st.session_state:
    st.session_state.smtp_cfg = {'host': '', 'port': 587, 'username': '', 'password': '', 'use_tls': True}

# -------------------------
# Dashboard
# -------------------------
if menu == "Dashboard":
    st.header("Dashboard & Reporting")
    period = st.selectbox("Select period for lifecycle (month)", ["September 2025", "October 2025", "All time"])  # placeholder
    metrics = build_dashboard_metrics()

    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Total Employees", metrics['total_employees'])
    col2.metric("Customers (Accounts)", metrics['acct_count'])
    col3.metric("Billed FTEs", metrics['billed_total'])
    col4.metric("Unbilled FTEs", metrics['unbilled_total'])

    st.subheader("Active vs Resigned")
    fig = px.pie(names=["Active", "Resigned"], values=[metrics['active'], metrics['resigned']], title="Active vs Resigned")
    st.plotly_chart(fig, use_container_width=True)

    st.subheader("Band-wise Distribution")
    if metrics['band_counts']:
        df_band = pd.DataFrame(list(metrics['band_counts'].items()), columns=["Band", "Count"])
        st.bar_chart(df_band.set_index('Band'))
    else:
        st.info("No band data available")

    st.subheader("Technology Tower")
    if metrics['tech']:
        df_tech = pd.DataFrame(list(metrics['tech'].items()), columns=["Technology", "Count"])
        st.bar_chart(df_tech.set_index('Technology'))

    st.subheader("Top billed projects")
    if metrics['project_billed']:
        df_proj = pd.DataFrame(list(metrics['project_billed'].items()), columns=["Project", "BilledFTE"])
        st.table(df_proj.head(10))
    else:
        st.info("No allocation data")

# -------------------------
# Employee Master
# -------------------------
elif menu == "Employee Master":
    st.header("Employee Master Record")
    st.subheader("Add new employee")
    with st.form("add_employee_form"):
        emp_code = st.text_input("Employee Code")
        name = st.text_input("Full name")
        band = st.selectbox("Band", ["B1", "B2", "B3", "B4"], index=1)
        technology = st.text_input("Technology")
        gender = st.selectbox("Gender", ["Male", "Female", "Other"]) 
        grad = st.text_input("Grad")
        reporting_manager = st.text_input("Reporting Manager (name)")
        email = st.text_input("Email")
        submitted = st.form_submit_button("Create")
        if submitted:
            if not emp_code or not name:
                st.error("Employee Code and Name required")
            else:
                try:
                    emp_id = create_employee(emp_code, name, band, technology, gender, grad, reporting_manager, email, current_user)
                    st.success(f"Employee {name} created successfully (ID {emp_id})")
                except Exception as e:
                    st.error(str(e))

    st.subheader("Existing employees")
    df_emp = get_employees_df()
    st.dataframe(df_emp)

    sel = st.selectbox("Select employee for actions", df_emp['id'].tolist() if not df_emp.empty else [])
    if sel:
        row = df_emp[df_emp['id'] == sel].iloc[0]
        st.write(row.to_dict())
        col1, col2, col3 = st.columns(3)
        if col1.button("Edit"):
            with st.form("edit_emp"):
                new_name = st.text_input("Name", value=row['name'])
                new_band = st.text_input("Band", value=row['band'])
                new_tech = st.text_input("Technology", value=row['technology'])
                new_gender = st.selectbox("Gender", ["Male","Female","Other"], index=["Male","Female","Other"].index(row['gender']) if row['gender'] in ["Male","Female","Other"] else 0)
                new_status = st.selectbox("Status", ["Active","Resigned"], index=0 if row['status']=='Active' else 1)
                submitted2 = st.form_submit_button("Save")
                if submitted2:
                    update_employee(sel, name=new_name, band=new_band, technology=new_tech, gender=new_gender, status=new_status, performed_by=current_user)
                    st.success("Updated")
        if col2.button("Delete"):
            delete_employee(sel, current_user)
            st.success("Deleted")
        if col3.button("View Audit Trail"):
            conn = get_conn()
            audit_df = pd.read_sql_query("SELECT * FROM audit WHERE entity_type='employee' AND entity_id = ? ORDER BY performed_at DESC", conn, params=(sel,))
            conn.close()
            st.dataframe(audit_df)

# -------------------------
# Account Onboarding
# -------------------------
elif menu == "Account Onboarding":
    st.header("Onboard new customer / project")
    with st.form("onboard"):
        customer_name = st.text_input("Customer name")
        project_name = st.text_input("Project name")
        project_codes_text = st.text_area("Project codes (comma separated)")
        finance_id = st.text_input("Finance ID")
        delivery_stakeholder = st.text_input("Delivery stakeholder (name)")
        submitted = st.form_submit_button("Create accounts")
        if submitted:
            codes = [c.strip() for c in project_codes_text.split(',') if c.strip()]
            if not customer_name or not project_name or not codes:
                st.error("Customer name, project name and at least one project code required")
            else:
                ids = create_account(customer_name, project_name, codes, finance_id, delivery_stakeholder, current_user)
                st.success(f"New account {customer_name} - {project_name} created with {len(ids)} project codes and linked stakeholder {delivery_stakeholder}")

    st.subheader("Existing accounts")
    conn = get_conn()
    acc_df = pd.read_sql_query("SELECT * FROM accounts", conn)
    conn.close()
    st.dataframe(acc_df)

# -------------------------
# Allocations
# -------------------------
elif menu == "Allocations":
    st.header("Manage Allocations")
    emp_df = get_employees_df()
    conn = get_conn()
    acc_df = pd.read_sql_query("SELECT * FROM accounts", conn)
    conn.close()

    with st.form("alloc_form"):
        emp_id = st.selectbox("Employee", emp_df['id'].tolist() if not emp_df.empty else [])
        account_id = st.selectbox("Account (project)", acc_df['id'].tolist() if not acc_df.empty else [])
        project_code = st.text_input("Project Code")
        billed = st.number_input("Billable FTE", min_value=0.0, value=1.0, step=0.25)
        unbilled = st.number_input("Unbillable FTE", min_value=0.0, value=0.0, step=0.25)
        ef = st.date_input("Effective from", date.today())
        et = st.date_input("Effective to (optional)", value=None)
        notes = st.text_area("Notes")
        notify = st.checkbox("Send email notification on change", value=False)
        submitted = st.form_submit_button("Create Allocation")
        if submitted:
            try:
                smtp_cfg = st.session_state.smtp_cfg if notify else None
                create_allocation(emp_id, account_id, project_code, billed, unbilled, ef.isoformat(), et.isoformat() if et else None, notes, current_user, notify=notify, smtp_cfg=smtp_cfg)
                st.success("Allocation created")
            except Exception as e:
                st.error(str(e))

    st.subheader("Allocations table")
    st.dataframe(get_allocations_df())

# -------------------------
# Import/Export
# -------------------------
elif menu == "Import/Export":
    st.header("Import / Export Reports")
    uploaded = st.file_uploader("Upload Excel for employees (columns: emp_code,name,band,technology,gender,grad,reporting_manager,email)", type=['xlsx','xls'])
    if uploaded:
        bytes_data = uploaded.read()
        count, errors = import_employees_from_excel(bytes_data, current_user)
        st.success(f"{count} employee records imported successfully.")
        if errors:
            st.warning(f"Validation errors: {len(errors)}")
            st.write(pd.DataFrame(errors, columns=["Row", "Error"]))

    st.subheader("Export: Employees / Allocations")
    df_emp = get_employees_df()
    df_alloc = get_allocations_df()
    if st.button("Export Employees to Excel"):
        towrite = io.BytesIO()
        with pd.ExcelWriter(towrite, engine='openpyxl') as writer:
            df_emp.to_excel(writer, sheet_name='employees', index=False)
        towrite.seek(0)
        st.download_button("Download Employees.xlsx", data=towrite, file_name="employees.xlsx")

    if st.button("Export Allocations to Excel"):
        towrite = io.BytesIO()
        with pd.ExcelWriter(towrite, engine='openpyxl') as writer:
            df_alloc.to_excel(writer, sheet_name='allocations', index=False)
        towrite.seek(0)
        st.download_button("Download Allocations.xlsx", data=towrite, file_name="allocations.xlsx")

# -------------------------
# Lifecycle
# -------------------------
elif menu == "Lifecycle":
    st.header("Monthly Lifecycle Tracking")
    df_alloc = get_allocations_df()
    df_emp = get_employees_df()

    month = st.selectbox("Select month", ["September 2025", "October 2025", "All time"])  # placeholder
    # For demo, provide simple filters
    st.subheader("New Joiners")
    # naive: consider created_at in employees
    if not df_emp.empty:
        df_emp['created_at'] = pd.to_datetime(df_emp['created_at'])
        recent = df_emp[df_emp['created_at'] >= pd.to_datetime('2025-09-01')]
        st.write(recent[['emp_code','name','created_at']])
    else:
        st.info("No employee history available")

    st.subheader("Planned Releases / Resignations")
    # placeholder empty
    st.info("Use filters from allocations and employee status to generate lists. Export available using Export tab.")

# -------------------------
# Admin Console
# -------------------------
elif menu == "Admin Console":
    st.header("Admin Module - RBAC & Users")
    st.subheader("Create user / assign role")
    with st.form("user_form"):
        username = st.text_input("Username")
        full_name = st.text_input("Full name")
        role = st.selectbox("Role", ["Viewer", "Editor", "Dashboard Admin", "SysAdmin"], index=2)
        email = st.text_input("Email")
        submitted = st.form_submit_button("Create user")
        if submitted:
            if not username:
                st.error("Username required")
            else:
                create_user(username, full_name, role, email)
                st.success(f"User {username} granted role {role}")

    st.subheader("Existing users")
    st.dataframe(get_users_df())

# -------------------------
# Audit Trail
# -------------------------
elif menu == "Audit Trail":
    st.header("Audit Trail")
    conn = get_conn()
    df_audit = pd.read_sql_query("SELECT * FROM audit ORDER BY performed_at DESC LIMIT 500", conn)
    conn.close()
    st.dataframe(df_audit)
    emp_filter = st.text_input("Filter by employee code or name (substring)")
    if emp_filter:
        conn = get_conn()
        df_emp = pd.read_sql_query("SELECT * FROM employees WHERE name LIKE ? OR emp_code LIKE ?", conn, params=(f"%{emp_filter}%", f"%{emp_filter}%"))
        conn.close()
        st.write(df_emp)

# -------------------------
# Settings
# -------------------------
elif menu == "Settings":
    st.header("Application Settings")
    st.subheader("SMTP settings (for notifications)")
    s = st.session_state.smtp_cfg
    s['host'] = st.text_input("SMTP Host", value=s.get('host',''))
    s['port'] = st.number_input("SMTP Port", value=int(s.get('port',587)))
    s['username'] = st.text_input("SMTP Username", value=s.get('username',''))
    s['password'] = st.text_input("SMTP Password", value=s.get('password',''), type='password')
    s['use_tls'] = st.checkbox("Use TLS", value=s.get('use_tls', True))
    if st.button("Save SMTP"):
        st.session_state.smtp_cfg = s
        st.success("SMTP settings saved for this session")

    st.subheader("Current session user")
    st.write(current_user)

# End of file
